   
// ToTextBuilderBase.WriteElement: Plain vanilla implementation; performance approx 10x slower than optimized versions  
public IToTextBuilderBase WriteElement<T> (Expression<Func<T>> expression)
{
  ArgumentUtility.CheckNotNull ("expression", expression);
  var variableName = RightUntilChar (expression.Body.ToString (), '.');
  var variableValue = expression.Compile () ();
  return WriteElement (variableName, variableValue);
}

// ToTextBuilderBase.WriteElement: Optimized implementation; Performance about 1,5x slower than the current caching implementation.
public IToTextBuilderBase WriteElementFast2<T> (Expression<Func<T>> expression)
{
  ArgumentUtility.CheckNotNull ("expression", expression);

  var memberExpression = CheckWriteElementExpression<MemberExpression> (expression.Body, expression);
  var memberField = CheckWriteElementExpression<FieldInfo> (memberExpression.Member, expression);
  var closureExpression = CheckWriteElementExpression<ConstantExpression> (memberExpression.Expression, expression);

  object closure = closureExpression.Value;

  object variableValue = memberField.GetValue (closure);
  string variableName = memberExpression.Member.Name;
  return WriteElement (variableName, variableValue);
}

private T CheckWriteElementExpression<T> (object expressionItem, LambdaExpression expression)
    where T : class
{
  T itemAsT = expressionItem as T;
  if (itemAsT == null)
    throw new ArgumentException ("ToTextBuilder.WriteElement currently supports only expressions of the form () => varName. The expression: " + Environment.NewLine + expression.Body.ToString () + Environment.NewLine + " does not comply with this restriction.");

  return itemAsT;
}


// Performance for 100,000 executions: 4600ms as compared to 8ms for calling ArgumentUtility.CheckNotNull ("...", ...).
public static void ArgumentUtilityWithLambdaExpression<T> (Expression<Func<T>> expression)
{
  try
  {
    var memberExpression = (MemberExpression) expression.Body;
    var memberField = (FieldInfo) memberExpression.Member;
    var closureExpression = (ConstantExpression) memberExpression.Expression;

    object closure = closureExpression.Value;

    Assertion.DebugAssert (closure != null);
    Type closureType = closure.GetType ();

    // memberField.GetValue (closure);

    Func<object, object> getValueFunction;
    var key = new Tuple<Type, FieldInfo> (closureType, memberField);
    if (!s_getValueFunctionCache.TryGetValue (key, out getValueFunction))
    {
      getValueFunction = s_getValueFunctionCache.GetOrCreateValue (key,
        delegate
        {
          //
          // The following code builds this expression:
          // Expression<Func<object,object> = (object closure) => (object) ((TClosure) closure).<memberField>;
          //
          var param = Expression.Parameter (typeof (object), "closure");
          var closureAccess = Expression.Convert (param, closureType);
          var body = Expression.Field (closureAccess, memberField);
          var bodyAsObject = Expression.Convert (body, typeof (object));
          var newExpression = Expression.Lambda (bodyAsObject, param);
          return (Func<object, object>) newExpression.Compile ();
        }
      );
    }
    // Can this be sped up for the special case of testing for null ?
    object variableValue = getValueFunction (closure); 
    if (variableValue != null)
    {
      return;
    }
    string variableName = memberExpression.Member.Name;
  }
  catch (InvalidCastException)
  {
    throw new ArgumentException ("AssertUtilityTest currently supports only expressions of the form () => varName. The expression: " + Environment.NewLine + expression.Body.ToString () + Environment.NewLine + " does not comply with this restriction.");
  }
}