// This file is part of the re-motion Core Framework (www.re-motion.org)
// Copyright (c) rubicon IT GmbH, www.rubicon.eu
// 
// The re-motion Core Framework is free software; you can redistribute it 
// and/or modify it under the terms of the GNU Lesser General Public License 
// as published by the Free Software Foundation; either version 2.1 of the 
// License, or (at your option) any later version.
// 
// re-motion is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of 
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with re-motion; if not, see http://www.gnu.org/licenses.
// 
using System;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using Remotion.Mixins.Utilities.Singleton;
using Remotion.Reflection;
using Remotion.Text;
using Remotion.Utilities;
using Remotion.Mixins.Context;
using Remotion.Logging;

namespace Remotion.Mixins.CodeGeneration
{
  /// <summary>
  /// Provides a way to build concrete types for target and mixin classes in mixin configurations and maintains a cache for built types.
  /// </summary>
  /// <remarks>
  /// <para>
  /// This class represents a thread-safe global singleton. You can access the single instance via the 
  /// <see cref="ThreadSafeSingletonBase{TSelf,TCreator}.Current"/> property and replace it via the 
  /// <see cref="ThreadSafeSingletonBase{TSelf,TCreator}.SetCurrent"/> method.
  /// </para>
  /// <para>
  /// The names of the assemblies generated by the <see cref="ConcreteTypeBuilder"/> is determined by the <see cref="IModuleManager"/> it uses.
  /// </para>
  /// </remarks>
  /// <threadsafety static="true" instance="true" />
  public class ConcreteTypeBuilder
      : ThreadSafeSingletonBase<IConcreteTypeBuilder, ServiceLocatorInstanceCreator<IConcreteTypeBuilder>>, IConcreteTypeBuilder
  {
    private static readonly ILog s_log = LogManager.GetLogger (typeof (ConcreteTypeBuilder));

    private readonly CodeGenerationCache _cache = new CodeGenerationCache ();

    private readonly IConcreteMixedTypeNameProvider _mixedTypeNameProvider;
    private readonly IConcreteMixinTypeNameProvider _mixinTypeNameProvider;

    private readonly object _scopeLockObject = new object ();
    private readonly IModuleManager _scope;

    public ConcreteTypeBuilder (
        IModuleManager moduleManager,
        IConcreteMixedTypeNameProvider mixedTypeNameProvider,
        IConcreteMixinTypeNameProvider mixinTypeNameProvider)
    {
      ArgumentUtility.CheckNotNull ("moduleManager", moduleManager);
      ArgumentUtility.CheckNotNull ("mixedTypeNameProvider", mixedTypeNameProvider);
      ArgumentUtility.CheckNotNull ("mixinTypeNameProvider", mixinTypeNameProvider);

      _scope = moduleManager;
      _mixedTypeNameProvider = mixedTypeNameProvider;
      _mixinTypeNameProvider = mixinTypeNameProvider;
    }

    /// <summary>
    /// Gets the cache used to cache types generated by this <see cref="ConcreteTypeBuilder"/>.
    /// </summary>
    /// <value>The cache used for building types.</value>
    public CodeGenerationCache Cache
    {
      get { return _cache; }
    }

    /// <summary>
    /// Gets or sets the <see cref="IModuleManager"/> used by this <see cref="ConcreteTypeBuilder"/>. The object returned by this property must not 
    /// be used by multiple threads at the same time (or while another thread executes methods on <see cref="ConcreteTypeBuilder"/>) since it is
    /// not guaranteed to be thread-safe. Use <see cref="LockAndAccessScope"/> to access the <see cref="Scope"/> in a thread-safe way.
    /// </summary>
    /// <value>The module scope of this <see cref="ConcreteTypeBuilder"/>.</value>
    public IModuleManager Scope
    {
      get
      {
        return _scope;
      }
    }

    /// <summary>
    /// Provides thread-safe access to the module scope of <see cref="ConcreteTypeBuilder"/>, see also <see cref="Scope"/>.
    /// </summary>
    /// <param name="scopeAccessor">A delegate accessing the scope while access to it is locked.</param>
    /// <remarks>This methods locks the scope while executing <paramref name="scopeAccessor"/>. This ensures that no other method of
    /// <see cref="ConcreteTypeBuilder"/> modifies the scope while it is being accessed.</remarks>
    public void LockAndAccessScope (Action<IModuleManager> scopeAccessor)
    {
      lock (_scopeLockObject)
      {
        scopeAccessor (Scope);
      }
    }

    /// <summary>
    /// Gets the name provider used when generating a concrete mixed type.
    /// </summary>
    public IConcreteMixedTypeNameProvider TypeNameProvider
    {
      get { return _mixedTypeNameProvider; }
    }

    /// <summary>
    /// Gets the name provider used when generating a concrete mixin type.
    /// </summary>
    public IConcreteMixinTypeNameProvider MixinTypeNameProvider
    {
      get { return _mixinTypeNameProvider; }
    }

    /// <summary>
    /// Gets the concrete mixed type for the given target class configuration either from the cache or by generating it.
    /// </summary>
    /// <param name="classContext">The <see cref="ClassContext"/> holding the mixin configuration for the target class.</param>
    /// <returns>A concrete type with all mixins from <paramref name="classContext"/> mixed in.</returns>
    /// <remarks>This is mostly for internal reasons, users should use <see cref="TypeFactory.GetConcreteType(Type)"/> instead.</remarks>
    public Type GetConcreteType (ClassContext classContext)
    {
      ArgumentUtility.CheckNotNull ("classContext", classContext);

      lock (_scopeLockObject)
      {
        return Cache.GetOrCreateConcreteType (Scope, classContext, _mixedTypeNameProvider, this);
      }
    }

    /// <inheritdoc />
    public IConstructorLookupInfo GetConstructorLookupInfo (ClassContext classContext, bool allowNonPublic)
    {
      ArgumentUtility.CheckNotNull ("classContext", classContext);

      lock (_scopeLockObject)
      {
        return Cache.GetOrCreateConstructorLookupInfo (Scope, classContext, _mixedTypeNameProvider, this, allowNonPublic);
      }
    }

    /// <summary>
    /// Gets the concrete type for the given mixin class configuration either from the cache or by generating it.
    /// </summary>
    /// <param name="concreteMixinTypeIdentifier">The <see cref="ConcreteMixinTypeIdentifier"/> defining the mixin type to get.</param>
    /// <returns>A concrete type for the given <paramref name="concreteMixinTypeIdentifier"/>.</returns>
    /// <remarks>This is mostly for internal reasons, users will hardly ever need to use this method.</remarks>
    public ConcreteMixinType GetConcreteMixinType (ConcreteMixinTypeIdentifier concreteMixinTypeIdentifier)
    {
      ArgumentUtility.CheckNotNull ("concreteMixinTypeIdentifier", concreteMixinTypeIdentifier);

      lock (_scopeLockObject)
      {
        return Cache.GetOrCreateConcreteMixinType (Scope, concreteMixinTypeIdentifier, _mixinTypeNameProvider);
      }
    }

    /// <summary>
    /// Saves the concrete types and mixin types generated by this <see cref="IConcreteTypeBuilder"/> to disk. The <see cref="Scope"/> is reset, 
    /// so that the builder can continue to generate types.
    /// The names of the assemblies used by this method depend on the <see cref="Scope"/>. It is recommended to provide a configured 
    /// <see cref="IModuleManager"/> instance when constructing the <see cref="ConcreteTypeBuilder"/> in order to configure the assembly names.
    /// </summary>
    /// <returns>An array containing the paths of the assembly files saved.</returns>
    /// <remarks>
    /// <para>
    /// This method is similar to directly calling <see cref="Scope"/>.<see cref="IModuleManager.SaveAssemblies"/> , but in addition resets the 
    /// <see cref="Scope"/> via <see cref="IModuleManager.Reset"/>. That way, the builder can continue to generate types even when the dynamic 
    /// assemblies have been saved. Note that each time this method is called, only the types generated since the last save operation are persisted. 
    /// Also, if the scope isn't reconfigured to save at different paths, previously saved assemblies might be overwritten.
    /// </para>
    /// </remarks>
    public string[] SaveGeneratedConcreteTypes ()
    {
      s_log.Info ("Saving built types...");
      lock (_scopeLockObject)
      {
        string[] paths;
        if (Scope.HasSignedAssembly || Scope.HasUnsignedAssembly)
          paths = Scope.SaveAssemblies();
        else
          paths = new string[0];

        _scope.Reset();
        return paths.LogAndReturn (s_log, LogLevel.Info, result => "Saved files: " + SeparatedStringBuilder.Build (", ", result));
      }
    }

    /// <inheritdoc />
    public void LoadConcreteTypes (Assembly assembly)
    {
      LoadConcreteTypes ((_Assembly) assembly);
    }

    /// <summary>
    /// Imports the public concrete types and mixin types from the given <see cref="Assembly"/> into this <see cref="IConcreteTypeBuilder"/> instance.
    /// </summary>
    /// <param name="assembly">The assembly whose public types to load.</param>
    /// <remarks>
    /// This overload exists primarily for testing purposes; it has the same functionality as <see cref="LoadConcreteTypes(System.Reflection.Assembly)"/>.
    /// </remarks>
    [CLSCompliant (false)]
    public void LoadConcreteTypes (_Assembly assembly)
    {
      ArgumentUtility.CheckNotNull ("assembly", assembly);
      s_log.InfoFormat ("Loading assembly {0} into cache...", assembly);

      using (StopwatchScope.CreateScope (s_log, LogLevel.Info, "Time needed to load assembly into cache: {elapsed}."))
      {
        AssemblyName assemblyName = assembly.GetName();
        if (assemblyName.Name == Scope.SignedAssemblyName || assemblyName.Name == Scope.UnsignedAssemblyName)
        {
          string message = string.Format (
              "Cannot load assembly '{0}' into the cache because it has the same name as one of the dynamic assemblies used "
              + "by the mixin engine. Having two assemblies with the same name loaded into one AppDomain can cause strange and sporadic "
              + "TypeLoadExceptions.",
              assemblyName.Name);
          throw new ArgumentException (message, "assembly");
        }

        var types = assembly.GetExportedTypes();
        s_log.InfoFormat ("Assembly {0} has {1} exported types.", assemblyName, types.Length);
        Cache.ImportTypes (types, new AttributeBasedMetadataImporter());
      }
    }

    /// <inheritdoc />
    public void InitializeUnconstructedInstance (IMixinTarget mixinTarget)
    {
      ArgumentUtility.CheckNotNull ("mixinTarget", mixinTarget);
      Scope.InitializeMixinTarget (mixinTarget);
    }

    /// <inheritdoc />
    public void InitializeDeserializedInstance (IMixinTarget mixinTarget, object[] mixinInstances)
    {
      ArgumentUtility.CheckNotNull ("mixinTarget", mixinTarget);
      Scope.InitializeDeserializedMixinTarget (mixinTarget, mixinInstances);
    }

    /// <inheritdoc />
    public IObjectReference BeginDeserialization (Func<Type, Type> typeTransformer, SerializationInfo info, StreamingContext context)
    {
      ArgumentUtility.CheckNotNull ("typeTransformer", typeTransformer);
      ArgumentUtility.CheckNotNull ("info", info);

      return Scope.BeginDeserialization (typeTransformer, info, context);
    }

    /// <inheritdoc />
    public void FinishDeserialization (IObjectReference objectReference)
    {
      ArgumentUtility.CheckNotNull ("objectReference", objectReference);
      Scope.FinishDeserialization (objectReference);
    }
  }
}
