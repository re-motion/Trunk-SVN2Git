// This file is part of the re-motion Core Framework (www.re-motion.org)
// Copyright (c) rubicon IT GmbH, www.rubicon.eu
// 
// The re-motion Core Framework is free software; you can redistribute it 
// and/or modify it under the terms of the GNU Lesser General Public License 
// as published by the Free Software Foundation; either version 2.1 of the 
// License, or (at your option) any later version.
// 
// re-motion is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of 
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with re-motion; if not, see http://www.gnu.org/licenses.
// 
using System;
using System.Linq;
using NUnit.Framework;
using Remotion.Reflection;
using Remotion.Utilities;
using Remotion.Validation.Implementation;
using Remotion.Validation.IntegrationTests.TestDomain.ComponentA;
using Remotion.Validation.Rules;
using Remotion.Validation.Validators;

namespace Remotion.Validation.IntegrationTests
{
  [TestFixture]
  public class FluentValidationGlobalizationIntegrationTests : IntegrationTestBase
  {
    private PropertyValidationRule _propertyValidationRule;
    private Customer _customer;

    /* Note: 
     *   > ValidationFailure.ErrorMessage displays a user-friendly property name (generated by PropertyRule.GetDisplayName) 
     *   > ValidationFailure.PropertyName represents the technical property name (generated by PropertyRule.BuildPropertyName)
     */

    public override void SetUp ()
    {
      base.SetUp();

      var property = PropertyInfoAdapter.Create (MemberInfoFromExpressionUtility.GetProperty ((Customer c) => c.LastName));
      var propertyValidators = new IPropertyValidator[] { new NotNullValidator() };
      _propertyValidationRule = new PropertyValidationRule (property, propertyValidators);
      _customer = new Customer();
    }

    [Test]
    public void Validate_NoExplicitPropertyNameSet ()
    {
      var result = _propertyValidationRule.Validate (new ValidationContext (_customer)).ToArray().First();

      Assert.That (result.PropertyName, Is.EqualTo ("LastName"));
      Assert.That (result.ErrorMessage, Is.EqualTo ("'LastName' must not be empty."));
      Assert.Ignore ("RM-5906: TODO globalization");
      Assert.That (result.ErrorMessage, Is.EqualTo ("'Last Name' must not be empty."));
    }

    [Test]
    public void Validate_PropertyChain ()
    {
      var result =
          _propertyValidationRule.Validate (
              new ValidationContext (_customer, new PropertyChain (new[] { "ChainedProperty1", "Chainedroperty2" }), new DefaultValidatorSelector()))
                       .ToArray();

      var validationResult = result.Single();
      Assert.That (validationResult.PropertyName, Is.EqualTo ("ChainedProperty1.Chainedroperty2.LastName"));
      Assert.That (validationResult.ErrorMessage, Is.EqualTo ("'ChainedProperty1.Chainedroperty2.LastName' must not be empty."));
      Assert.Ignore ("RM-5906: TODO globalization");
      Assert.That (validationResult.ErrorMessage, Is.EqualTo ("'Last Name' must not be empty."));
    }

    [Test]
    public void DefaultErrorMessage_NotNullValidator ()
    {
      var validator = new NotNullValidator();

      // TODO: originally this was Is.TypeOf (LocalizedStringSource) (and all tests below)
      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.NotNullError));
    }

    [Test]
    public void DefaultErrorMessage_NotEmptyValidator ()
    {
      var validator = new NotEmptyValidator (null);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.NotEmptyError));
    }

    [Test]
    public void DefaultErrorMessage_NotEqualValidator ()
    {
      var validator = new NotEqualValidator (null);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.NotEqualError));
    }

    [Test]
    public void DefaultErrorMessage_EqualValidator ()
    {
      var validator = new EqualValidator (null);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.EqualError));
    }

    [Test]
    public void DefaultErrorMessage_ExactLengthValidator ()
    {
      var validator = new ExactLengthValidator (10);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.ExactLengthError));
    }

    [Test]
    public void DefaultErrorMessage_MaxLengthValidator ()
    {
      var validator = new LengthValidator (1, 3);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.LengthError));
    }

    [Test]
    public void DefaultErrorMessage_ExclusiveBetweenValidator ()
    {
      var validator = new ExclusiveBetweenValidator (1, 3);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.ExclusiveBetweenError));
    }

    [Test]
    public void DefaultErrorMessage_InclusiveBetweenValidator ()
    {
      var validator = new InclusiveBetweenValidator (1, 3);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.InclusiveBetweenError));
    }

    [Test]
    public void DefaultErrorMessage_LessThanValidator ()
    {
      var validator = new LessThanValidator (1);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.LessThanError));
    }

    [Test]
    public void DefaultErrorMessage_LessThanOrEqualValidator ()
    {
      var validator = new LessThanOrEqualValidator (1);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.LessThanOrEqualError));
    }

    [Test]
    public void DefaultErrorMessage_GreaterThanValidator ()
    {
      var validator = new GreaterThanValidator (1);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.GreaterThanError));
    }

    [Test]
    public void DefaultErrorMessage_GreaterThanOrEqualValidator ()
    {
      var validator = new GreaterThanOrEqualValidator (1);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.GreaterThanOrEqualError));
    }

    [Test]
    public void DefaultErrorMessage_PredicateValidator ()
    {
      var validator = new PredicateValidator ((o1, o2, o3) => true);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.PredicateError));
    }

    [Test]
    public void DefaultErrorMessage_RegularExpressionValidator ()
    {
      var validator = new RegularExpressionValidator ("");

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.RegularExpressionError));
    }

    [Test]
    public void DefaultErrorMessage_ScalePrecisionValidator ()
    {
      var validator = new ScalePrecisionValidator (2, 5);

      Assert.That (validator.ErrorMessageSource, Is.TypeOf (typeof (StaticStringSource)));
      Assert.That (validator.ErrorMessageSource.GetString (), Is.EqualTo (Constants.ScalePrecisionError));
    }
  }
}