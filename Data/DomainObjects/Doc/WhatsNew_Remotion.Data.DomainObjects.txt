1.11.11
=======
- COMMONS-786 OppositeClassDefinitionRetriever should also support -1 in addition to IndexOutOfRangeExceptions for detecting missing columns.

1.11.7
======
- COMMONS-770 Change BindableDomainObject to work without using mixins
- COMMONS-766 Remove complicated Query constructors - use QueryFactory instead
- COMMONS-762 Add QueryCache
- COMMONS-761 Add QueryFactory.CreateQuery overloads

1.11.6
======
- COMMONS-760 Move Linq entry point from DataContext to new Query factory class
  from o in QueryFactory.CreateLinqQuery<Order>() ...

1.11.5
======
- COMMONS-758 QueryConfiguration reports duplicate queries.xml files if PrivateBinPath is string.Empty

1.11.4
======
- COMMONS-748 When mixing a persistent property where the virtual side is on a mixin and there are other mixins, RelationReflectorBase throws a MappingException
- COMMONS-746 EnumProperty: Enums with UndefinedEnumValueAttribute should behave like nullable Enums (i.e. not be required)
  Enum-Property (ObjectBinding): Fixed issue with UndefinedEnumValue-attributed enums behaving differently than nullable enums. 
  Now both enum-types will be treated as not required if they are nullable or have an undefined value.

1.11.3
======
- COMMONS-718 Support persistent mixins applied above the inheritance root
- COMMONS-717 Drop ICollection<T> from DomainObjectCollection to avoid type inferencing conficts in c# compiler when using ObjectList<T>
  DomainObjectCollection: Dropped ICollection<DomainObject> from DomainObjectCollection to avoid conflicts with type inferencing in Linq-queries
  when using ObjectList<T>.

1.11.2
======
- COMMONS-713 Allow "set" accessors for CollectionEndPoint-based properties
  This is to make auto-generated properties possible for ObjectList<T> properties:
  public virtual ObjectList<OrderItem> OrderItems { get; set; }
  
  The setter replaces the managed list with another list, which then becomes a managed list.
  If this behavior is not wanted, the setter should be made protected (or the property must be manually implemented via Properties or CurrentProperty).
  
- COMMONS-695 dbschema does not support StorageClass.Transaction
- COMMONS-688 Throw exception in DomainObject constructor if object is instantiated without the responsible creator

1.11.1
======
- COMMONS-694 Change default implementation for SQL data types genereted by dbschema.exe for string and binary data to nvarchar (n|max) and varbinary (n|max)
  dbschema.exe now generated SQL Server 2005 syntax instead of SQL Server 2000:
  string without a maximum length is now generated as nvarchar (max) instead of ntext.
  byte[] is now generated as varbinary (n|max) instead of image.


1.10.0
======
- COMMONS-686 Query files should be loaded relative to AppBase, default queries.xml should additionally be located in relative search paths

1.9.2
=====
- COMMONS-683 dbschema.exe cannot handle domains without any types
- COMMONS-684 Automatically implement virtual C#-3.0-automatic properties
  public virtual int OrderNumber { get; set; }
  
  This is similar to how the auto-implemented abstract properties worked, but without the abstract class requirement and the InstantiableAttribute.
  If a DomainObject has a non-virtual auto-property without StorageClassNoneAttribute, an exception is thrown.
  
- COMMONS-675 PropertyIndexer.Find does not support properties declared on generic types
- COMMONS-674 StorageClassTransaction
  Behaves exactly like the persistent storage class, but will not be persisted in the database. Instead, the respective property only lives in the
  ClientTransaction.

- COMMONS-672 Derived persistent mixins should support diamond-style inheritance
- COMMONS-671 ClassDefinition.ValidateCurrentMixinConfiguration doesn't check base class definition, so mixin changes to the base class aren't recognized
- COMMONS-668 Reflection-based should check that persistence-relevant mixins introduced by a base type are not suppressed on the derived type
- COMMONS-666 Open generic mixins are incorrectly reported to be relevant for persistence
- COMMONS-558 Provide support for derived persistent mixins
- COMMONS-476 Provide a Clone feature for DomainObjects
- COMMONS-682 Support automatic properties

1.9.0
=====
- COMMONS-646 Allow ClientTransaction.CopyCollectionEventHandlers to use discarded transactions as a source
- COMMONS-640 Eliminate Data.DomainObjects.Web
  - COMMONS-642 Add Remotion.Web.WxeScopedTransaction, Remotion.Data.ITransactionManager, and Remotion.Data.ITransactionScope"
- COMMONS-639 Restructure DomainObject unit test folders
- COMMONS-638 Rename Remotion.Security.Data.DomainObjects project to Remotion.Data.DomainObjects.Security
- COMMONS-626 Remove NullableValueTypes
- COMMONS-622 Add Data.Interfaces project
- COMMONS-619 Remove Legacy projects
- COMMONS-601 Rename Rubicon framework to Remotion
- COMMONS-289 Reorganize folder structure in Data.DomainObjects.UnitTests

1.7.87
======
- COMMONS-493 Make DomainObjectTransporter more efficient by only serializing those objects that really are transported
- COMMONS-571 Provide simple XML serialization support for transported domain objects
- COMMONS-569 Provide serialization hooks in DomainObjectTransporter and DomainObjectImporter
- COMMONS-577 Use EncodedCodeBase in ReflectionUtility.GetAssemblyPath and rename GetExecutingAssemblyPath to something more sensible (it always returns the Data.DomainObjects assembly)
- COMMONS-573 Ensure transport transaction cannot be rolled back or committed
- COMMONS-572 Make binary DomainObject transport independent of framework version
- COMMONS-499 Decide upon and implement error handling when two mixins add persistent relation properties referencing the same opposite property

1.7.86
======
- COMMONS-566	Make IClientTransactionListener.PropertyValueChanging/Changed also fire for relation properties
- COMMONS-243 Transport of domain objects + data to another system
  - COMMONS-393	Add hook to manipulate exported objects
- COMMONS-567	Mixed relation IDs are not unique over multiple target classes

1.7.85
======
- COMMONS-565 SubClientTransaction should throw when it is used while its parent is writable (rather than throw assertions)
- COMMONS-554 Rename ClientTransaction.NewTransaction to ClientTransaction.NewRootTransaction to avoid confusion
- COMMONS-551 RelationReflector assigns wrong RelationIDs for mixed relation properties
- COMMONS-547 Refactor ValueConverter.GetMandatoryOppositeClassDefinition
- COMMONS-546 Fix error message when a query is executed that returns null values
- COMMONS-543 SqlProvider should support null ClassID columns when ID column is also null
- COMMONS-475 Define behavior of QueryManager.GetCollection with duplicates in the result set
- COMMONS-563 Fehler beim Zugriff auf bereits geladenes Objekt in SubTransaction während im Aufruf von GetCollection in SubTransaction

1.7.81
======
- COMMONS-496 Add support for mixed relation properties, where a mixin adds a relation to a DomainObject class
- COMMONS-491 Wrong LoadMode in OnLoaded method is given when a DomainObject is loaded in a subtransaction after being newly created in the parent tx
- COMMONS-490 Ensure _bindingTransaction is correctly serialized if concrete domain object implements ISerializable
- COMMONS-489 Ensure DataContainer of an object is loaded when accessing its related objects
- COMMONS-338 Add possibility to bind DomainObject instances or graphs to a specific ClientTransaction
  - COMMONS-487 Add ClientTransaction.NewBindingTransaction
  - COMMONS-488 Make DomainObjects created in scope of BindingClientTransaction automatically bound to that transaction
- COMMONS-486 Remove SerializableAttributes from diverse data management classes
- COMMONS-388 Add possibility to control traversal in GetFlattenedRelatedObjectGraph
- COMMONS-389 Add filtered DomainObjectTransporter.LoadRecursive
- COMMONS-381 Add affinity between TransportedDomainObjects.TransportedObjects and DataTransaction


1.7.80
======
- COMMONS-474 Improve serialization performance by serializing a whole ClientTransaction as one flattened object array
- COMMONS-473 Build performance tests for serialization
- COMMONS-471 Commit ordering of DomainObjectCollections from subtransactions to parent transactions
- COMMONS-469 Make mapping classes more efficient to serialize by removing ISerializable interface and requiring serialized instances to be part of the current mapping

1.7.76
======
- COMMONS-452 DomainObject should provide BaseGetObjectData method for domain objects implementing ISerializable to work correctly
- COMMONS-448 Remove LoadIntoTransaction
- COMMONS-446 Derive SimpleDomainObject from DomainObject and provide public NewObject<>/GetObject<>
- COMMONS-445 Remove non-generic New/GetObject methods from DomainObject and provide Infrastructure.RepositoryAccessor.New/Get/DeleteObject
- COMMONS-438 Replace usages of AssemblyFinder with ContextAwareTypeDiscoveryService
- COMMONS-361 Add DebuggerDisplayAttribute: IBusinessObject/WithIdentity implementations, DomainObject, OPF mapping


1.7.75
======
- COMMONS-441 Inherit initial AutoEnlist value from parent transaction scope

1.7.74.0
========
- COMMONS-390	Fixed	ClientTransaction.GetObjects
- COMMONS-392	Fixed	"COMMONS-243
  Provide more efficient import"
- COMMONS-423	Fixed	SubClientTransaction.Commit triggers delete/relation change events in parent transaction
- COMMONS-428	Fixed	"COMMONS-423
  Make RelationEndPoint.PerformRelationChange callable independently of Begin/EndRelationChange"

1.7.72.0
========
- COMMONS-416 FIXED  DesignMode Support for BindableDomainObjects  

1.7.71.0
========
- COMMONS-400 FIXED  Make WhereClauseBuilder mixable
- COMMONS-403 FIXED  Designer should not cause MixinConfiguration to load files in VS directory, which leads to an exception

1.7.70.0
========
- COMMONS-391 FIXED  Refactor ConcreteTableInheritanceRelationLoader, extract features to load data containers from a command and from a list of
  ObjectIDs  

1.7.69.0
========
- COMMONS-394 FIXED  Provide better error message when two domain object classes have the same simple name
- COMMONS-397 FIXED  Re-add obsolete QueryConfiguration.Current
- COMMONS-399 FIXED  Provide TransportedDomainObjects.FinishTransport

1.7.68.0
========
- COMMONS-374 Fixed  Data Allow for multiple queries.xml files per application
  - COMMONS-375 Fixed  Data Change QueryConfiguration into a ConfigurationSection
- COMMONS-379 Fixed  Data Provide DomainObjectTransporter object
- COMMONS-380 Fixed  Data Provide DomainObjectTransporter.LoadTransportData
- COMMONS-382 Fixed  Data Throw on duplicate queries defined in different queries.xml files
- COMMONS-383 Fixed  Data Remove explicit name attribute from <queryfiles> configuration collection

1.7.67.0
========
- COMMONS-345 Fixed  Generated types don't handle deserialization events correctly
  - COMMONS-370 Fixed  Types generated by OPF should trigger deserialization events
  - COMMONS-371 Fixed  Mixed domain objects should trigger deserialization events
- COMMONS-360 Fixed  Mixed domain objects should not require same mixin configuration on deserialization

1.7.66.0
========
- COMMONS-330 FIXED  Add PropertyAccessor.HasBeenTouched      
  - COMMONS-333 FIXED  Add PropertyValue.HasBeenTouched      
  - COMMONS-334 FIXED  Add ObjectEndPoint.HasBeenTouched      
  - COMMONS-335 FIXED  Add CollectionEndPoint.HasBeenTouched w/ DomainObjectCollection.HasBeenTouched      
  - COMMONS-336 FIXED  Integrate HasBeenTocued to PropertyAccessor.HasBeenTouched      
- COMMONS-327 FIXED  Change property set behavior: HasChanged should be false when property is set back to original value      
- COMMONS-358 FIXED  Explicitly forbid open generic domain object mixins      
- COMMONS-329 FIXED  Persistence for mixed properties in a static configuration      
  - COMMONS-346 FIXED  Provide DomainObjectMixin<T>      
  - COMMONS-347 FIXED  Make reflection-based mapping include properties of mixins derived from DomainObjectMixin      
  - COMMONS-348 FIXED  Add mixin configuration check at DomainObject instantiation time      
- COMMONS-351 FIXED  PropertyAccessor.GetRelatedObjectID      
- COMMONS-354 FIXED  Remove EnterScope ambiguities      
  - COMMONS-355 FIXED  Rename ReturnToParent, EnterScope, and EnterNonReturningScope to Discard, EnterDiscardingScope, and EnterNonDiscardingScope      
  - COMMONS-356 FIXED  Change EnterDiscardingScope to also discard root transactions for consistency      
- COMMONS-331 FIXED  Use HasBeenTouched on BindableDomainObjectMixin and Legacy.BindableDomainObject to determine whether a property still has its default value      

1.7.65.0
========
- COMMONS-291 FIXED  Adapt BindableDomainObjectMixin to exclude ID property and to get information from the mapping
- COMMONS-303 FIXED  Add ClientTransaction.EnlistDomainObjects (IEnumerable<DomainObject>)
- COMMONS-304 FIXED  Add feature to calculate graph of domain objects    
  - COMMONS-318 FIXED  Add DomainObject.GetAllRelatedObjects      
  - COMMONS-319 FIXED  Add DomainObject.GetFlattenedRelatedObjectGraph  
- COMMONS-325 FIXED  Changing an object twice in a parent subtransaction and a child subtransaction loses the changes made in the parent subtransaction
- COMMONS-311 FIXED  EnlistDomainObject (and related) should not cause the enlisted objects to be loaded; load should only occur on first access
- COMMONS-322 FIXED  Implement ISearchAvailableObjectsService for bindable domain objects
- COMMONS-320 FIXED  Provide feature to copy event handlers on ResetTransaction
- COMMONS-312 FIXED  Re-add ClientTransaction.Current

1.7.64.0
========
- COMMONS-307 FIXED  EnlistSameDomainObjects throws on second call when object has been deleted in database

1.7.63.0
========
- COMMONS-293 FIXED  EnlistSameDomainObjects most probably causes problems when accessing related objects from the OnLoaded event handler

1.7.62.0
========
- DomainObject.OnLoaded hat jetzt einen LoadMode-Parameter, der angibt, ob das ganze Objekt geladen wurde, oder nur ein neuer DataContainer
  geladen wurde. Diese Unterscheidungsmöglichkeit ist nötig, da OnLoaded in Kombination mit EnlistDomainObject sowie Subtransaktionen mehrfach
  ausgeführt werden kann.
- COMMONS-294 FIXED  Adjust event args of DomainObject.OnLoaded to reflect whether the object was created together with the load      
- COMMONS-296 FIXED  EnlistSameDomainObjects throws when object has been deleted in database      
- COMMONS-299 FIXED  Implement GetObject for bindable domain objects      
- COMMONS-298 FIXED  Mixins.TypeUtility should provide a method to get the base target type for a concrete type      
- COMMONS-297 FIXED  ObjectFactory should recognize when called on generated type      
- COMMONS-292 FIXED  OnLoaded event caused by EnlistDomainObject cannot access object's properties      

1.7.61.0
========
- ClientTransaction.EnlistSameDomainObjects
- COMMONS-280 FIXED  Abstrakte Eigenschaft mit StorageClassNone Attribute wird nicht unterstützt      
- COMMONS-281 FIXED  DataContainer.CreateCloneWithNewID      

1.7.57.0
========
- ClientTransactionScope-Konstruktor ist jetzt internal; statt dessen ClientTransaction.EnterScope/EnterNonReturningScope bzw.
  ClientTransactionScope.EnterNullScope benutzen

- QueryManager-Klasse wurde durch IQueryManager-Interface ersetzt (zwei konkrete Implementierungen: RootQueryManager und SubQueryManager,
  für RootClientTransactions bzw. SubClientTransactions)

- TransactionalAccessor für das einfache Zugreifen auf Properties in anderen Transaktionen:
  
  [StorageClassNone]
  public TransactionalAccessor<int> OrderNumberTx
  {
    get { return GetTransactionalAccessor<int> (Properties[typeof (Order), "OrderNumber"]); }
  }
  
  public static void Test()
  {
    Order order = ...;
    ClientTransaction tx1 = ...; // make sure order is enlisted in tx1
    ClientTransaction tx2 = ...; // make sure order is enlisted in tx2
    
    order.OrderNumberTx[tx1] = 7;
    order.OrderNumberTx[tx2] = 8;
    
    Console.WriteLine (order.OrderNumberTx[tx1]); // 7
    Console.WriteLine (order.OrderNumberTx[tx2]); // 8
  }
  
- Mixins für Domänen-Objekte können IDomainObjectMixin implementieren, um über Erzeugung und Laden des Objekts informiert zu werden.

1.7.55.0
========
- Gemixte DomainObjects, vorerst noch ohne Einfluss auf das Mapping (d.h. Mixins auf DomainObjects können Interfaces hinzufügen,
  Methoden überschreiben, etc., aber hinzugefügte Properties werden nicht als Storage-Properties betrachtet)

1.7.48.0
========
- order.Properties[typeof (Order), "OrderNumber"] zusätzlich zu order.Properties["Rubicon.Data.DomainObjects.UnitTests.TestDomain.Order.OrderNumber"]
- order.Properties.Find (order, "OrderNumber") als Alternative, die ab dem statischen Typ von order auch alle Basistypen absucht

1.7.47.0
========
- WxeTransactedFunction und WxeTransaction wurden um einen neuen Transaktionsmodus erweitert (CreateChildIfParent)
- DomainObjects, die als Parameter an WxeTransactedFunctions übergeben oder als Out-Parameter zurückgegeben werden, werden automatisch in der
  entsprechenden Transaktion registriert

1.7.46.0
========
- Neue Transaktionsklassen: RootClientTransaction (entspricht bisheriger ClientTransaction), SubClientTransaction
- Verweundung von Subtransaktionen: 
using (myTransaction.CreateSubTransaction().EnterScope())
{
  // Änderungen innerhalb dieses Scopes werden beim Commit in myTransaction geschrieben, nicht in die Datenbank
}
- Falls kein Scope benutzt wird, muss ClientTransaction.ReturnToParentTransaction aufgerufen werden, um die Subtransaktion zu verwerfen
- ClientTransaction.EnlistDomainObject statt DomainObject.EnlistInTransaction

1.7.45.0
========
- Bugfix: RPA mit Attribut-Mapping konnte nicht mit Enums umgehen, die keinen 0-Wert hatten.

- DomainObject.Properties ist nun enumerierbar und hat eine Count-Eigenschaft

- DomainObjects sind nicht mehr direkt mit einem DataContainer verbunden, die Daten kommen immer aus der aktuellen ClientTransaction.
- DomainObject.DataContainer wird nur mehr aus Kompatibilitätsgründen angeboten und sollte nicht mehr benutzt werden; die Methoden des
  zurückgegebenen Objeks arbeiten auf den Daten aus der aktuellen ClientTransaction.
- DomainObjects können zunächst nur in jener Transaktion benutzt werden, in der sie geladen oder erzeugt wurden
  (DomainObjects.InitialClientTransaction). Durch DomainObject.EnlistInTransaction kann erlaubt werden, dieselbe DomainObject-Instanz auch in anderen
  Transaktionen zu benutzen. Um Änderungen aus einer Transaktion in eine andere mitzunehmen, müssen diese jedoch vor dem Aufruf von
  EnlistInTransaction committed werden.

- Die aktuelle Transaktion ist nicht mehr über ClientTransaction.Current, sondern über ClientTransactionScope.CurrentTransaction abrufbar.
- Der aktuelle ClientTransactionScope ist über ClientTransactionScope.ActiveScope abrufbar.
- ClientTransactionScope.AutoRollbackBehavior kann benutzt werden, um am Ende eines Scopes ein automatisches Rollback aller nicht committeten
  Änderungen durchzuführen.
- ClientTransactionScope.AutoEnlistDomainObjects bewirkt, dass DomainObjects anderer Transaktionen automatisch in der vom Scope verwalteten
  Transaktion verwendet werden dürfen (ohne explizit EnlistInTransaction aufzurufen).

1.7.43.0
========

- Explizite Interface-Implementierungen werden nun nicht mehr per default Teil des Mappings. 
  Sie können mit StorageClassAttribute (StorageClass.Transaction) explizt in das Mapping aufgenommen werden.
  
- DomainObject.DataContainer, Get/SetRelatedObject und GetRelatedObjects sind obsolet und sollte nicht mehr benutzt werden (stattdessen
  CurrentProperty und Properties[...] verwenden). DomainObject.DataContainer liefert keinen DataContainer mehr, sondern ein "Indirection"-Objekt
  mit ähnlicher Schnittstelle, so dass Legacy-Code weiter compiliert werden kann.
  
  Regular Expressions für das Ersetzen der alten Methoden mit neuen:
  "\({:i(\.:i)*}\):b*DataContainer\.GetValue:b*\({:q}\)"
  "\({:i(\.:i)*}\):b*DataContainer:b*\[{:q}\]"
  "\({:i(\.:i)*}\):b*GetRelatedObject:b*\({:q}\)"
  "\({:i(\.:i)*}\):b*GetRelatedObjects:b*\({:q}\)"
  -> "Properties[\2].GetValue<\1>()"
  
  "DataContainer\.SetValue:b*\({:q}, {:i(\.:i)*}\)"
  "DataContainer\[{:q}\] = {:i(\.:i)*}"
  "SetRelatedObject:b*\({:q}, {:i(\.:i)*}\)"
  -> "Properties[\1].SetValue (\2)"
  
- CurrentTransactionScope heißt jetzt ClientTransactionScope.  
- Der DomainObject-Konstruktor mit ClientTransaction-Parameter ist nun obsolet, seine Verwendung erzeugt einen Compiler-Fehler. ClientTransactionScope
  muss statt dessen verwendet werden.

1.7.42.0
========

- Klassen ClassDefinitionLoader, MappingLoader, RelationDefinitionLoader vom Namespace 
  Rubicon.Data.DomainObjects.ConfigurationLoader in Assembly Rubicon.Data.DomainObjects in den Namespace 
  Rubicon.Data.DomainObjects.Legacy.ConfigurationLoader.XmlBasedConfigurationLoader in Assembly Rubicon.Data.DomainObjects.Legacy verschoben.

- Klassen BaseFileLoader, ConfigurationNamespaceManager, LoaderUtility, PrefixNamespace, QueryConfigurationLoader vom Namespace 
  Rubicon.Data.DomainObjects.ConfigurationLoader in Assembly Rubicon.Data.DomainObjects in den Namespace 
  Rubicon.Data.DomainObjects.ConfigurationLoader.XmlBasedConfigurationLoader verschoben.

- Contructor Interface der Klasse SchemaLoader wurde verändert: Statt dem Constructor mit SchemaType sind nun die well-known Instanzen
  SchemaLoader.Queries, LegacySchemaLoader.Mapping, und LegacySchemaLoader.StorageProviders zu verwenden.

- Klasse StorageProviderdefinition: Obsolete Property StorageProviderID wurde entfernt. Stattdessen zu verwenden: Property Name
- Klasse PropertyDefinition: Property ColumnName ist obsolete. Stattdessen zu verwenden: Property StorageSpecficName

- Klasse StorageProviderConfigurationLoader: gelöscht.
- Klasse StorageProviderCollection: gelöscht. Statt dessen leifert die Konfiguration ein Objekt vom Typ ProviderCollection<StorageProviderDefinition>.
- StorageProviderConfiguration.Current ist obsolete. Statt dessen ist DomainObjectsConfiguration.Current.Storage zu verwenden.
- Für Testing-Zwecke kann DomainObjectsConfiguration.SetCurrent mit der Klasse FakeDomainObjectsConfiguration initialisiert werden.

- Angabe des StorageProviders in der app.config:
  <configuration>
  
    <configSections>
      <sectionGroup name="rubicon.data.domainObjects" type="Rubicon.Data.DomainObjects.Configuration.DomainObjectsConfiguration, Rubicon.Data.DomainObjects">
        <section name="storage" type="Rubicon.Data.DomainObjects.Persistence.Configuration.PersistenceConfiguration, Rubicon.Data.DomainObjects" />
      </sectionGroup>
    </configSections>

    <rubicon.data.domainObjects xmlns="http://www.rubicon-it.com/Data/DomainObjects/Configuration/2.0">
      <storage defaultProviderDefinition="TheSqlProvider">
        <providerDefinitions>
          <add type="Rubicon.Data.DomainObjects::Persistence.Rdbms.RdbmsProviderDefinition"
              name="TheSqlProvider"
              providerType="Rubicon.Data.DomainObjects::Persistence.Rdbms.SqlProvider"
              connectionString="TheConnectionString"/>
        </providerDefinitions>
      </storage>
    </rubicon.data.domainObjects>

    <connectionStrings>
      <add name="TheConnectionString" connectionString="Integrated Security=SSPI;Initial Catalog=TheDatabase;Data Source=localhost"/>
    </connectionStrings>

  </configuration>

- CurrentTransactionScope: Per Using-Block benutzen, um temporär die aktuelle ClientTransaction zu setzen.

- Neue Factory-Methoden für DomainObjects: Generell diese benutzen, DomainObjects nicht mehr via "new" anlegen. (Alter Mechanismus funktioniert für
  Legacy-Objekte weiterhin.)
  DomainObject.GetObject<T> (ObjectID): Lädt bestehende DomainObjects
  DomainObject.NewObject<T> (): Erzeugt ein neues DomainObject
  
  Beide Methoden sind protected. In jeder konkreten DomainObject-Subklasse sollte es daher statische Factory-Methoden geben, die an NewObject<T> 
  bzw. GetObject<T> delegieren. 
  
  NewObject<T> liefert nicht direkt das konstruierte Objekt, sondern einen Invocation-Wrapper, der dazu dient, typsicher den richtigen Konstruktor 
  auszuwählen. Das Objekt wird erst durch einen Aufruf der With-Methode des Wrappers wirklich erzeugt.
  
  Beispiel:
  
  [...]
  class Order : DomainObject
  {
    public static Order NewObject ()
    {
      return NewObject<Order> ().With();
    }
  
    public static Order NewObject (int i, string s)
    {
      return NewObject<Order> ().With(i, s);
    }

    public static Order NewObject (ClientTransaction clientTransaction)
    {
      using (new CurrentTransactionScope (clientTransaction))
      {
        return NewObject<Order>().With();
      }
    }
    
    protected Order()
    {
    }
    
    protected Order (int i, string s)
    {
    }
    
    ...
  }

- Keine vorgeschriebenen Konstruktoren mehr: DomainObjects müssen für das Reflection-basierte Mapping keine speziellen Konstruktoren mehr
  implementieren. Der Infrastruktur-Konstruktor wird nicht mehr benutzt (beim Laden eines Objekts wird gar kein Konstruktor ausgeführt), sein
  Vorhandensein führt zu einer Exception.
  
  Folgender reguläre Ausdruck hilft dabei, die Konstruktoren per Visual-Studio-Find/Replace zu finden (und gegebenenfalls zu entfernen):
  \n:b*protected :i \(DataContainer :i\)(([^\}])*\n)*(([^\}])*\n)*(([^\}])*\n)*.*\}\n
  (Die Zeilenumbrüche sind eventuell anzupassen.)

- Neuer Property-Zugriff (für DomainObjects, die von der Factory erzeugt werden; alter Mechanismus funktioniert weiterhin unverändert):

  Bisher:
  public int IntProperty
  {
    get { return (int) DataContainer["Namespace.Type.IntProperty"]; }
    set { DataContainer["Namespace.Type.IntProperty"] = value; }
  }
  
  public MyDomainObject ObjectProperty
  {
    get { return (MyDomainObject) GetRelatedObject ("Namespace.Type.ObjectProperty"); }
    set { SetRelatedObject ("Namespace.Type.ObjectProperty", value); }
  }
 
  public DomainObjectCollection CollectionProperty
  {
    get { return GetRelatedObjects ("Namespace.Type.CollectionProperty"); }
  }
 
  
  Neu 1 - Property-Identifier wird automatisch zugeordnet, Property muss virtuell sein:
  public virtual int IntProperty
  {
    get { return CurrentProperty.GetValue<int>(); }
    set { CurrentProperty.SetValue (value); }
  }
  
  public MyDomainObject ObjectProperty
  {
    get { return CurrentProperty.GetValue<MyDomainObject>(); }
    set { CurrentProperty.SetValue() (value); }
  }
 
  public ObjectList<MyDomainObject> CollectionProperty
  {
    get { return CurrentProperty.GetValue<ObjectList<MyDomainObject>>(); }
  }

  Neu 2 - Property wird automatisch implementiert, Klasse wird dadurch abstrakt, muss mit InstantiableAttribute gekennzeichnet werden:
  public abstract int IntProperty { get; set; }
  public abstract MyDomainObject ObjectProperty { get; set; }
  public abstract ObjectList<MyDomainObject> CollectionProperty { get; set; }
  
  Statt CurrentProperty kann auch Property[string propertyName] verwendet werden. In disem Fall muss der Propertyname
  explizit übergeben werden (Format: Namespace.Class.Property). 
  
  Die bisherigen Get- und Set-Methoden werden bis zur Version 2.0 auf obsolete gesetzt.

- Search & Replace für neue Property Accessors
  Find what: public {.*}\n:b*\{:b*\n:b*get.*\n:b*set.*\n:b*\}*\n
  Replace with: public abstract \1 { get; set; }\n

  Find what: public {.*}\n:b*\{:b*\n:b*get.*\n:b*\}*\n
  Replace with: public abstract \1 { get; }\n

- QueryDefinition.QueryID entfernt.
- Query.QueryID entfernt.
- Strong-Typed Get-Mehoden auf DataContainer entfernt. Statt dessen ist der Indexer mit einem Cast zu verwenden.

- Rubicon.Data.DomainObjects.Web.ExecutionEngine.WxeTransactedFunction
  CreateWxeTransaction () ist nun sealed. Es ist nur noch CreateWxeTransaction (bool, bool) zu überschreiben.

- Rubicon.Data.DomainObjects.Mapping.NullRelationEndPointDefinition: umbenannt zu AnonymousRelationEndPointDefinition.

- Rubicon.Data.DomainObjects.ObjectBinding.BindableDomainObjects und BindableSearchObjects unterstüzen nun .NET Nullable Types.
  
- Rubicon.Data.DomainObjects.Persistence.ValueConverterBase verwendet nun StorageProviderDefinition.TypeConversionProvider 
  statt hart-kodierter Konvertierungen.

- DomainObjects: DefaultValues sind bei ReflectionBasedMapping nun wie folgt implementiert:
  nullable Properties: null
  Binaries: leeres Array
  String: String.Empty
  Alle weiteren Typen: Default Constructor

- dbschema.exe
  Commandline-Utility um Datenbank-Scripte für das Mapping zu erzeugen.
  
- DOGen.exe
  * Man muss nun das Config-File für die Applikation angeben, für das die Domäne bzw. die Datenbank-Scripte erstellt werden sollen (Parameter: config).
  * Neuer Parameter classesForAttributeMapping: Generiert das Domainmodel nach den Richtlinien des neuen, attribut-basierten Mappings.

- DataContainer: Methoden IsNull(...) und IsNullOrEmpty(...) entfernt.
  Sollten diese Methoden in einem Projekt dennoch benötigt werden, bietet sich an, sie im Layer-Supertype zu implementieren.
  public bool IsNull (string propertyName)
  {
    ArgumentUtility.CheckNotNullOrEmpty ("propertyName", propertyName);
    CheckDiscarded ();

    object value = this[propertyName];

    if (value == null)
      return true;

    INaNullable naNullable = value as INaNullable;
    if (naNullable != null)
      return naNullable.IsNull;

    return false;
  }

  public bool IsNullOrEmpty (string propertyName)
  {
    ArgumentUtility.CheckNotNullOrEmpty ("propertyName", propertyName);
    CheckDiscarded ();

    if (IsNull (propertyName))
      return true;

    object value = this[propertyName];
    
    if (value.GetType () == typeof (string))
      return (((string) value) == string.Empty);
    
    if (value.GetType () == typeof (Guid))
      return (((Guid) value) == Guid.Empty);

    if (value.GetType () == typeof (byte[]))
      return (((byte[]) value).Length == 0);

    return false;
  }

- ClientTransaction.Delete (...), DomainObject.Delete(), ClientTransaction.GetObject (...) von public zu protected geändert.
  Sie sollten nur selektiv auf Projektbasis (oder granularer) freigegeben werden.
  Für einen einfachen Fix in Projekten bietet sich der Layer-Super-Type an, um diese Methoden für DomainObject zu implementiern.

- ContainsMappingAttribute markiert Assemblies die Typen des Domain-Layers enthalten. Es muss angegeben werden, damit diese Assemblies beim 
  Aufbau des Mappings berücksichtigt werden.

1.7.37.0
========

- Bugifx: DoGen hat statt "ntext" "text" als SQL Datentyp für unbegrenzte Strings generiert.

1.7.34.0
========

- DoGen kann nun eine eigene SqlFileBuilder Klasse angegeben werden um andere SQL Dialekte (statt T-SQL) zu unterstüzten.
  Diese muss von Rubicon.Data.DomainObjects.CodeGenerator.Sql.SqlFileBuilderBase ableiten.

1.7.33.0
========

- Das Erzeugen eines IDbCommand-Objects wird nicht mehr von Rubicon.Data.DomainObjects.Persistence.Rdbms.CommandBuilder übernommen.
  Diese Aufgabe übernimmt der Rubicon.Data.DomainObjects.Persistence.Rdbms.RdbmsProvider, damit das Erzeugen projektspezifisch angepasst werden kann.


1.7.31.0
========

- DoGen generiert jetzt in den SQL Skripts das Schema dbo für alle erstllten oder gelöschten Objekte. 
  Dadurch kann über Suchen-Ersetzen dieses Schema einfach auf ein anderes Schema geändert werden.
- Neue protected Methode DomainObject.CheckIfObjectIsDiscarded zum Überprüfen, ob ein Object discarded ist.
- ValueConverter wird vom RdbmsProvider erstellt (es kann also pro Provider ein Converter abgeleitet werden).
- RdbmsProvider kann Identifier delimiten (zB. [Identifier], "Identifier" ...).
- RdbmsProvider kann Terminierung für Statement liefern (zB. ";").
- Div. Klassen (v.a. CommandBuilder) bekommen Provider übergeben und verwenden dessen neue Features.
- Achtung: Div. Unit Tests verwenden diese Features noch nicht (erzeugen Statements und ValueConverter hard coded).

1.7.30.0
========

- SqlProvider
  * Property Connection gibt SqlConnection statt IDbConnection zurück
  * Property Transaction gibt SqlTransaction statt IDbTransaction zurück
  * GetColumnsFromSortExpression prüft jetzt ob das Objekt bereits disposed wurde und wirft eine ObjectDisposedException 

- Die Reihenfolge von Events und ClientTransactionExtension-Benachrichtigungen wurde geändert, damit kaskadierte Löschvorgänge
  in der Applikationsdomäne, die durch das Deleted-Event auf einem in der aktuellen Transaktion erzeugten Objekt angestoßen werden, 
  zu keiner Exception führen.

- Breaking Change: Alle DomainObjectCollection-Changed Events (Adding, Added, Removing, Removed) haben nun einen einheitlichen 
  Delegate DomainObjectCollectionChangeEventHandler mit einheitlichen DomainObjectCollectionChangeEventArgs.
  Notwendige Schritte für Upgrade:
    * Alle Vorkommnisse von DomainObjectCollectionChangingEventHandler und DomainObjectCollectionChangedEventHandler 
      durch DomainObjectCollectionChangeEventHandler ersetzen.
    * Alle Vorkommnisse von DomainObjectCollectionChangingEventArgs und DomainObjectCollectionChangedEventArgs 
      durch DomainObjectCollectionChangeEventArgs ersetzen.


1.7.29.0
========

- PersistenceManager: Werden beim Laden eines Objektes über eine 1:1-Beziehung und einen virtuellen Endpunkt 
  mehrere Objekte gefunden, wird nicht mehr das erste zurückgegeben, sondern eine PersistenceException geworfen.


1.7.28.0
========

- Property ClientTransaction.ApplicationData:
  Typ des Keys auf System.Enum geändert um Konflikte bei der Vergabe von Keys zu vermeiden.

- Bugfix für Concrete Table Inheritance:
  RPF verwendet jetzt "UNION ALL" statt "UNION" um die Datentypen text, ntext und image bei der Selektion von Daten 
  aus mehreren Tabellen zu unterstützen. Von DOGen generierte Views verwenden jetzt ebenfalls "UNION ALL".


1.7.18.0
========

- Property ClientTransaction.ApplicationData vom Typ Dictionary<string, object> hinzugefügt.


1.7.13.0
========

- Folgende Framework-interne Methoden/Properties in BindableDomainObject und BindableSearchObject 
  wurden entweder zu privaten Methoden/Properties oder zu expliziten Interface-Implementierungen umgewandelt, 
  um das Interface einfacher zu machen:
  * GetBusinessObjectProperty -> privat
  * BusinessObjectClass -> explizite Interface-Implementierung
  * this[IBusinessObjectProperty] Indexer -> explizite Interface-Implementierung
  * this[string] Indexer -> explizite Interface-Implementierung
  * GetPropertyString (string) -> explizite Interface-Implementierung
  * GetPropertyString (IBusinessObjectProperty) -> explizite Interface-Implementierung 
  * GetPropertyString (IBusinessObjectProperty, string) -> explizite Interface-Implementierung -> Methode ist jetzt nicht mehr virtual!
  * GetProperty (string) -> explizite Interface-Implementierung  
  * GetProperty (IBusinessObjectProperty) -> explizite Interface-Implementierung  
  * SetProperty (string, object) -> explizite Interface-Implementierung  
  * SetProperty (IBusinessObjectProperty, object) -> explizite Interface-Implementierung  

- Bei Property IBusinessObjectWithIdentity.UniqueIdentifier wurde EditorBrowsable = Never entfernt, damit bei einem expliziten Cast auf
  das Interface die Property in der IntelliSense aufscheint.
  
- Da die folgenden Framework-Properties der DomainObject-Klasse normalerweise nicht auf einer GUI-Maske angezeigt werden sollen, 
  werden sie jetzt vom Property Picker zur Design Time nicht mehr angezeigt:
  * IsDiscarded
  * State
  * ClientTransaction
  * ID
  
    
1.7.12.0
========

- Klassen DomainObject und ClientTransaction stellen neue Events zur Verfügung:
  * RollingBack
  * RolledBack

- IClientTransactionExtension.RollingBack und IClientTransactionExtension.RolledBack bekommen jetzt ebenfalls 
  die betroffenen DomainObjects übergeben.

- Mapping.xml:
  * Die Reihenfolge der Subelemente von class- und property-Elementen ist ab sofort frei wählbar. 
    -> Beim Element relationProperty bleibt die Reihenfolge relevant, damit das Schema deterministisch bleibt.
  * Das Element "column" ist bei property-Elementen nun optional. Wird es ausgelassen, wird der selbe Wert wie in propertyName angenommen.
    -> Bei relationProperties muss "column" weiterhin angegeben werden, damit das Framework erkennt welche Seite einer Beziehung den Foreign Key speichert.
    
- MaxLength Element ist jetzt im Mapping optional:
  * Damit können string-Eigenschaften beliebiger Länge gespeichert werden.
  * DoGen generiert für diesen Fall Spalten vom Typ text. Achtung: Diese können im SQL Server nicht bei einer Query mit dem = Operator abgefragt werden!     

- MandatoryRelationNotSetException beinhaltet ab sofort 2 neue Properties:
  * DomainObject = Objekt bei dem die MandatoryRelationNotSetException aufgetreten ist.
  * PropertyName = Eigenschaft bei der die MandatoryRelationNotSetException aufgetreten ist.
  
- Neue Methode in ClientTransaction:
  * bool HasChanged ... Gibt zurück, ob sich mindestens ein Objekt im Zuge dieser Transaktion geändert hat.
  
- Änderung des Verhaltens beim Laden der Konfigurationsdateien (Mapping, StorageProviders, Queries):
  Wurde ein AppSetting (z.B. Rubicon.Data.DomainObjects.Mapping.ConfigurationFile) 
  angegeben und existiert die angegebene Datei nicht, wird sofort ein Fehler gemeldet und kein Fallback mehr
  auf den ExecutingAssemblyPath durchgeführt. Wurde kein AppSetting angegeben, ist das Verhalten wie bisher.
  
      
1.7.11.0
========

- DOGen:
  * Die erstellten Views für abstrakte Klassen sind jetzt mit SQL Server 2000 kompatibel.
  * Neue optionale Kommandozeilen-Parameter mappingFile und storageProvidersFile, mit denen man eigene Dateinamen für die 
    Konfigurationsdateien angeben kann.
  * Klassen werden nach dem neuen Styleguide erstellt.


1.7.10.0
========

- Reihenfolge der Events beim Löschen eines Objekts geändert:
  ALT: Deleting, RelationChanging, Deleted, RelationChanged
  NEU: Deleting, RelationChanging, RelationChanged, Deleted

- Reihenfolge der Events beim Einfügen in eine 1:n Beziehung geändert, ist jetzt identisch mit Ersetzen eines Objekts:
  ALT: Neues Objekt (n-Seite), altes Objekt (1-Seite) des neuen Objektes, bestendes Objekt (1-Seite)
  NEU: Neues Objekt (n-Seite), bestendes Objekt (1-Seite), altes Objekt (1-Seite) des neuen Objektes

- Auf der ClientTransaction können Extensions registriert werden. Dafür gibt es ein neues Interface IClientTransactionExtension und 
  eine neue Property ClientTransaction.Extensions. 
  Die Extensions werden über die folgende Vorgänge notifiziert:
  * Instanzieren neuer Objekte
  * Laden von Objekten
  * Löschen von Objekten
  * Auslesen und Ändern von Properties
  * Auslesen und Ändern von Beziehungen
  * Ausführen von Queries
  * Commit und Rollback
  

1.7.9.0
=======

- Event ClientTransaction.Loaded wird nicht mehr gefeuert, wenn beim Navigieren über eine Beziehung kein Objekt geladen wird.


1.7.7.0
=======

- Breaking Change: Property-Changed Events (PropertyValue, PropertyValueCollection, DataContainer, DomainObject) bekommen in 
  neuen PropertyChangeEventArgs jetzt zusätzlich den alten und neuen Wert übergeben => Changing- und Changed-Events
  mit neuem Delegate PropertyChangeEventHandler vereinheitlicht. 
  Notwendige Schritte für Upgrade:
    * Alle Vorkommnisse von PropertyChangingEventHandler und PropertyChangedEventHandler durch PropertyChangeEventHandler ersetzen.
    * Alle Vorkommnisse von PropertyChangingEventArgs und PropertyChangedEventArgs durch PropertyChangeEventArgs ersetzen.
  
- Für ClientTransaction-Extension-Infrastruktur wurde die Event-Reihenfolge von DataContainer.PropertyChanged und DomainObject.PropertyChanged geändert.
  ALT: DomainObject vor DataContainer.
  NEU: DataContainer vor DomainObject.

  
1.7.6.0
=======

- Mapping, StorageProviders, Queries:
  Die XML Schema Dateien Mapping.xsd, StorageProviders.xsd und Queries.xsd sind jetzt als Ressource in der Assembly
  Rubicon.Data.DomainObjects enthalten und müssen daher nicht mehr im bin Verzeichnis der Projekte liegen.

  Damit entfallen auch die folgenden web.config Einträge:
    * Rubicon.Data.DomainObjects.Mapping.SchemaFile
    * Rubicon.Data.DomainObjects.Persistence.Configuration.SchemaFile
    * Rubicon.Data.DomainObjects.Queries.Configuration.SchemaFile

- Concrete Table Inheritance:
  Hat eine Vererbungshierarchie abstrakte Basisklassen können deren abgeleitete Klassen in unterschiedliche Tabellen 
  persistiert werden. Dazu wird bei den abstrakten Klassen im Mapping kein <entity> Element angegeben. Jede Tabelle enthält
  dabei auch die Spalten der abstrakten Basisklassen.
  
  Bei der Generierung der SQL Skripts mit DoGen wird dies berücksichtigt. Weiters wird eine View pro Klasse erstellt, 
  die alle Objekte dieser und ihrere abgeleiteten Klassen zurückgibt. Diese können für Datenbankabfragen verwendet werden.
  
- Neue Methode ClassDefinition.IsSameOrBaseClassOf eingeführt.

- Beim Setzen einer Beziehung über SetRelatedObject wird nun auch der Typ des übergebenen Objekts kontrolliert.


1.7.2.0
=======

- Mapping: 
  Für die Implementierung von Concrete Table Inheritance dürfen ab dieser Version Eigenschaften zweier Klassen, die Teil 
  der selben Vererbungshierarchie sind, nicht die selben Spaltennamen verwenden. Dies gilt auch für Objektklassen, die 
  sich in parallelen Vererbungszweigen befinden.


1.7.1.0
=======

- Im Falle von ungültigen Datenbankwerten bei einer FK-Spalte wurden die Fehlermeldungen verbessert.


1.4.37.0
========

- Rubicon.Data.DomainObject.CommonCollection.CopyTo:
  Lieferte eine ArgumentException, wenn man versucht hat, eine leere Collection in ein leeres Array zu kopieren => Behoben.
  

1.4.26.0
========

- Rubicon.Data.DomainObjects.Mapping.MappingConfiguration:
  Hat einen neuen Konstruktor-Parameter resolveTypes. Wird dieser auf false gesetzt, wird das gesamte Mapping geladen,
  aber keine .NET-Typen aufgelöst. Dieses Feature ist vor allem für Codegeneratoren sinnvoll, die für das Generieren
  die MappingConfiguration nutzen. Die Supporter-Klassen in den Namespaces Rubicon.Data.DomainObjects.Mapping und 
  Rubicon.Data.DomainObjects.ConfigurationLoader wurden ebenfalls entsprechend angepasst.


1.4.25.0
========

- Rubicon.Data.DomainObjects.ObjectBinding.Web.DomainObjectDataSourceControl:
  Im Build für .NET 2.0 wird jetzt auch der Designer für Web-Projekte und Web-Sites von Visual Studio 2005 korrekt unterstützt. 


1.4.10.0
========

- Rubicon.Data.DomainObjects.Web.ExecutionEngine.WxeTransactedFunction:
  Neue public property "Transaction", die eine Referenz auf die aktuelle ClientTransaction zurückgibt.

- BREAKING CHANGE: Rubicon.Data.DomainObjects.Web.ExecutionEngine.TransactionMode:
  Umbenannt in WxeTransactionMode, damit es keinen Konflikt mehr mit Property TransactionMode auf WxeTransactedFunction gibt.


1.4.9.0
=======

- Rubicon.Data.DomainObjects.Web.ExecutionEngine.WxeTransactedFunction:
  Neue Factory-Method CreateWxeTransaction (bool, bool) für das Einhängen von 
  eigenen WxeTransactions und damit von eigenen projekt-spezifischen ClientTransactions.


1.3.28.0
========

- Rubicon.Data.DomainObjects.DomainObjectCollection:
  * Contains (DomainObject) ist jetzt obsolete. Analoge Funktinalität bietet ContainsObject (DomainObject). In den häufigsten Anwendungsfällen
    sollten jedoch Aufrufe von Contains (domainObject) auf Contains (domainObject.ID) geändert werden.
  * Die DomainObjectCollection-Methoden/Properties Combine, this[int], Add und Insert verwenden jetzt Contains (domainObject.ID),
    um eine konsistente Verhaltensweise bei der Verwendung von mehreren ClientTransactions zu erzielen.
  * this[int] liefert jetzt eine verständlichere Fehlermeldung, wenn das übergebene DomainObject bereits in der Collection ist.
- Rubicon.Data.DomainObjects.Queries.QueryManager unterstützt jetzt offiziell Stored Procedures. Stored Procedures mit Parameter müssen exec verwenden!


1.3.21.0
========

- Neues Attribut Rubicon.Data.DomainObjects.ObjectBinding.UndefinedEnumValueAttribute für enum Typen:
  Das Attribut kann für Enums verwendet werden, die im DomainModel Pflicht sind, in Suchmasken jedoch optional sein können.
- Rubicon.Data.DomainObjects.ObjectBinding.IsRequiredAttribute:
  Setter von IsRequired entfernt und Klasse sealed gesetzt.
- Rubicon.Data.DomainObjects.ObjectBinding.ItemTypeAttribute:
  Setter von ItemType entfernt und Klasse sealed gesetzt.
- Rubicon.Data.DomainObjects.ObjectBinding.DateTypeAttribute:
  Setter von DateType entfernt und Klasse sealed gesetzt.
  

1.3.20.0
========

- RPF und RPA sind vollständig serialisierbar.
- Rubicon.Data.DomainObjects.ObjectBinding.BindableSearchObject: Property BusinessObjectClass gibt jetzt korrekterweise eine SearchObjectClass zurück.
- DOGen: Neuer Parameter "/serializable" um bei allen generierten Klassen das "[Serializable]" Attribut zu vergeben.

1.3.19.0
========

- Rubicon.Data.DomainObjects.CommonCollection hat neue Methode BaseContains, die zusätzlich zum Key object.Equals verwendet, um
  bei reference types zu prüfen, ob die übergebene Referenz Teil der Collection ist. 
  Für folgende Collections hat sich somit die Semantik der Contains-Overloads mit dem 
  Collection-Element (z.B. Contains (DataContainer), Contains (DomainObject)) geändert:
  * DataContainerCollection
  * RelationEndPointCollection
  * DomainObjectCollection
  * ClassDefinitionCollection
  * PropertyDefinitionCollection
  * RelationDefinitionCollection
  * StorageProviderDefinitionCollection
  * StorageProviderCollection
  * PropertyValueCollection
  * QueryDefinitionCollection
  * QueryParameterCollection
  
- Rubicon.Data.DomainObjects.Persistence.Configuration.StorageProviderDefinition:
  Property StorageProviderDefinitionID ist jetzt obsolet. In Zukunft sollte neue Property ID verwendet werden.

- Rubicon.Data.DomainObjects.Persistence.StorageProvider:
  Property StorageProviderDefinition in Definition umbenannt und visibility von protected auf public geändert.  

- Rubicon.Data.DomainObjects.Queries.Configuration.QueryDefinition:
  Property QueryID ist jetzt obsolet. In Zukunft sollte neue Property ID verwendet werden.

- Rubicon.Data.DomainObjects.Queries.IQuery:
  Property QueryID in ID umbenannt.
    
- Rubicon.Data.DomainObjects.Queries.Query:
  Property QueryID ist jetzt obsolet. In Zukunft sollte neue Property ID verwendet werden.
  
- Als Vorbereitung für die Serialisierungsfähigkeit von Rubicon.Data.DomainObjects notifizieren sich Objekte
  innerhalb des Frameworks nicht mehr über Events, sondern über eigene interne Methoden. Grund dafür ist, 
  dass .NET 1.1 keine Delegates serialisiert, die non-public methods (das bedeutet private, protected, internal) referenzieren. 
  
  
1.3.18.0
========

- Rubicon.Data.DomainObjects.Queries.QueryParameter:
  Value und ParameterType verfügen jetzt auch über einen Setter.


1.3.16.0
========

- Rubicon.Data.DomainObjects.ObjectID:
  * Klasse wurde auf sealed gesetzt.
  * Konstruktor-Overloads für Guid-, int- und sting-values entfernt.
  * Konstruktur-Overload für object-values von protected auf public geändert => CheckValue überprüft jetzt korrekten Typ.
  * Konstrukor verwendet StorageProvderDefinition, um zu prüfen, ob der StorageProvider der zugeordneten ClassDefinition
    den übergebenen value als object identifier unterstützt.

- Rubicon.Data.DomainObjects.Persistence.Configuration.StorageProviderDefinition:
  * Neue abstrakte Methode IsIdentityTypeSupported
  * Neue Methode CheckIdentityType, die eine IdentityTypeNotSupportedException wirft, 
    wenn übergebener Typ nicht als object identifier unterstützt wird.    

- Rubicon.Data.DomainObjects.Persistence:
  * Neue Exception ConverterException eingeführt.
  * ValueConverter gesplittet -> ValueConverterBase, ValueConverter -> Werfen statt RdbmsProviderExceptions ConverterExceptions.
  * Weiters kann ValueConverterBase nun auch beliebige string-Values in ihren korrekten Datentyp umwandeln.
  * Neues Interface IDataContainerFactory abstrahiert wie ein StorageProvider DataContainers erzeugt.
  * RdbmsProvider überprüft nicht mehr übergebene ObjectIDs, da für die Prüfung die ObjectID selbst verantwortlich ist.
  * RdbmsProvider definiert neue Factory-Methode CreateDataContainerFactory.
  * RdbmsProviderDefinition implementiert IsIdentityTypeSupported.
  * StorageProvider definiert neue protected Methode CheckQuery.
  
1.3.11.0
========

- Rubicon.Data.DomainObjects:
  * Der Konstruktor von QueryDefinition gibt bei fehlerhaften Konstruktorparametern im Exception-Text als Zusatzinformation 
    die queryID mit aus.
  * Neue public Property 'DomainObject.ClientTransaction'.
  * Beim Erzeugen eines neuen DomainObjects, das nicht im Mapping eingetragen ist, wird statt einer ArgumentNullException 
    eine MappingException geworfen.
  
- Rubicon.Data.DomainObjects.ObjectBinding:
  * ReferenceProperty.SearchAvailableObjects verwendet jetzt die ClientTransaction des übergebenen DomainObjects. Wenn das 
    übergebene Objekt kein DomainObject ist, wird ClientTransaction.Current verwendet.
  * Neue Assembly 'Rubicon.Data.DomainObjects.ObjectBinding.UnitTests'


1.3.9.0
=======

- Neue Exception ClientTransactionsDifferException: Wird von DomainObject, DomainObjectCollection und ClientTransaction geworfen,
  wenn Schreiboperationen auf Objekten mit unterschiedlicher ClientTransaction durchgeführt werden.

- Rubicon.Data.DomainObjects.CodeGenerator.Console (DOGen):
  Unterstützt den neuen Datentyp 'binary'. Im SQL Skript wird eine Spalte vom Datentyp 'image' erstellt, im generierten
  C# code eine Property vom Typ byte[].


1.3.8.0
=======

- Rubicon.Data.DomainObjects:
  Neuer Datentyp 'binary' im mapping.xsd eingeführt. Dieser dient zum Speichern von binären Daten (byte arrays) in BLOBs. 
  'MaxLength' wird für 'binary' unterstützt, ist aber optional.
  Neue Methode 'DomainObject.GetBytes ()' zum typisierten Lesen von byte arrays.
  'DomainObject.IsNull' und 'DomainObject.IsNullOrEmpty' unterstützen den neuen Datentyp.
  

1.3.7.0
=======

- Neue static property: ClientTransaction.HasCurrent eingeführt.
- Neue Assembly Rubicon.Data.DomainObjects.Web: Enthält WxeTransactedFunction mit WxeTransaction.
  Die WxeTransactedFunction verwaltet eine aktuelle ClientTransaction. Damit muss dies nicht mehr in der Applikation
  über die Session gesteuert werden. Ausserdem werden jetzt mehrere parallele Browser-Fenster direkt unterstützt.
  Subfunktionen können entweder eine neue Transaktion beginnen oder die der übergeordneten WXE-Funktion weiterverwenden.
  

1.2.43.0
========

- Rubicon.Data.DomainObjects.ObjectBinding.Web:
  * Attribut 'TagPrefix' ("dow") vergeben, da ansonsten VS-Designer eine nichtssagende Default-Präfix verwendet.
  * DomainObjectDataSourceControl: Wenn beim Einlesen des Mappings eine Exception ausgelöst wird, 
    wird jetzt keine MessageBox mehr angezeigt, sondern die Fehlermeldung in den Inhalt des Controls gerendert.
    
- Rubicon.Data.DomainObjects:
  Wird ein Objekt A, das in der aktuellen Transaktion neu angelegt wurde, im Committing-Event eines anderen Objektes B
  gelöscht, wird jetzt für Objekt A kein Committing Event mehr ausgelöst.
  

1.2.35.0
========

- Rubicon.Data.DomainObjects.ObjectBinding:
  * Wenn die Klasse, die bei einem ItemType-Attribut einer Collection-Property angegeben ist, nicht im Mapping vorkommt, wird
    jetzt eine MappingException statt einer ArgumentNullException geworfen.
  * Für Collection-Properties, die nicht im Mapping beschrieben sind, wird keine MappingException mehr ausgelöst, wenn das
    ItemType-Attribut fehlt. Per Default wird BindableDomainObject als Item-Type der Collection angenommen.
  
  
1.2.34.0
========
  
- ClassDefinition:
  * Bugfix für Beziehung in "Composite" Design Pattern: 
    1. GetMyRelationEndPointDefinitions liefert jetzt nur mehr alle Endpunkte der eigenen Klasse.
    2. GetRelationDefinitions funktioniert jetzt bei "Composite" Design Pattern richtig => Es kommt keine Exception mehr.
    3. Durch Behebung von Punkt 1 und Punkt 2 erzeugt DOGen jetzt bei "Composite" Design Patterns den richtigen Output (C# und SQL).
  * GetOppositeEndPointDefinition liefert keine Exception mehr, wenn gegenüberliegender Endpunkt nicht gefunden wird.
  * Neue Methode IsMyRelationEndPoint, die angibt, ob ein übergebener Endpunkt zu dieser Klasse gehört.
  * Neue Methode GetMandatoryRelationDefinition, die Exception liefert, wenn Beziehung nicht gefunden wird.
  * Neue Methode GetMandatoryOppositeClassDefinition, die Exception liefert, wenn gegenüberliegende Klasse nicht gefunden wird.
  * Neue Methode GetMandatoryRelationEndPointDefinition, die Exception liefert, wenn Endpunkt nicht gefunden wird. 
  * Neue Methode GetMandatoryOppositeEndPointDefinition, die Exception liefert, wenn gegenüberliegender Endpunkt nicht gefunden wird.
  * Neue Methode GetMandatoryPropertyDefinition, die Exception liefert, wenn Eigenschaft nicht gefunden wird.

- DomainObjectDataSourceControl:
  * Wird eine BocList auf ein DomainObjectDataSourceControl gebunden und zur Design Time eine Property über das GUI ausgewählt, wird eine 
    "Value cannot be null, Parameter name: classDefinition"-Exception geworfen, wenn die Objektklasse Collection-Properties beinhaltet, die
    nicht im Mapping vorkommen und das Attribut "ItemType" nicht gesetzt haben. Hier kommt jetzt eine sprechende Meldung. 
    Hinweis: In einem späteren Build wird das "ItemType"-Attribut optional sein und als ItemType "BindableDomainObject" angenommen.
    
- DomainObject und ClientTransaction Committing Events:
  * Wurde im DomainObject.Committing oder im ClientTransaction.Committing Event ein neu erzeugtes Objekt wieder gelöscht, wurde eine
    ObjectDiscardedException ausgelöst => Behoben.
  * DomainObject, DataContainer, PropertyValueCollection und PropertyValue haben neue Eigenschaft IsDiscarded.  
  
  
1.2.33.0
========

- Bugfixes DOGen:
  * Es werden jetzt auch Enums (die nicht als nested Types deklariert sind) erstellt.
  * Wenn der Typ einer Property in einem anderen Namespace liegt, wird der Typ vollqualifiziert angegeben.
  * Ein "using Rubicon.Data.DomainObjects.ObjectBinding" ist jetzt im Fileheader eingefügt.

- DomainObjectDataSourceControl:
  * Wird mapping.xml zur Design Time ausgelesen und enthält sie einen Fehler, wurde die Exception durch Visual Studio verschkluckt => 
    Lösung: Fehler abfangen und eigene MessageBox anzeigen.

- BooleanProperty:
  * GetDisplayName zeigt jetzt zusätzlich zu den englischen Texten auch lokalisierte deutsche Texte (Ja/Nein) an. 
    Hierfür gibt es eine sprachspezifische Satellite Assembly Rubicon.Data.DomainObjects.ObjectBinding.resources.dll


1.2.26.0
========

- NullableProperty
  * Liefert bei IsRequired nicht mehr _isNullable sonder base.IsRequired
  
- ReflectionPropertyFactory
  * Liefert bei IsPropertyRequired falls sonst nichts angegeben bei ReferenceTypes default false.

1.2.25.0
========

- Unterstützung für unidirektionale Beziehungen in mapping.xml:
  Element "relationProperty" nur auf einer Beziehungsseite definieren und Child-Element "oppositeClass" angeben =>
  Rubicon.Data.DomainObjects verwendet automatisch unidirektionale Beziehung => 
  Bei Änderungen werden auf dem gegenüberliegenden Objekt/Collection keine Events ausgelöst und kein State-Tracking durchgeführt.


1.2.18.0
========

- Rubicon.Data.DomainObjects.ObjectBinding: Die Property "ID" eines BindableDomainObjects scheint wieder in der IntelliSense auf. BindableDomainObject
  versteckt die Basisimplementierung von ID nicht mehr mit "new".


1.2.16.0
========

- "GOLDEN VERSION" von Rubicon.Data.DomainObjects und Rubicon.Data.DomainObjects.ObjectBinding


1.2.15.0
========

- Neue Assembly DOGen.exe eingeführt.
  Diese Assembly ist eine Konsolenanwendung zum automatischen Generieren des C# Source Codes eines Domain Models und der SQL Skripts für den 
  Datenbankaufbau.


1.2.14.0
========

- Neue Assembly Rubicon.Data.DomainObjects.CodeGenerator eingeführt.
  Diese Assembly bietet Klassen zum automatischen Generieren des C# Source Codes eines Domain Models und der SQL Skripts für den Datenbankaufbau.


1.2.13.0
========

- Klasse PerformanceCounters wurde entfernt, da die darunterliegende Windows API von Windows Server 2003 und Windows XP zum aktuellen Zeitpunkt
  einen nicht behobenen Bug aufweist. Details siehe:
  http://groups.google.at/groups?hl=de&lr=&newwindow=1&threadm=7%24tO0xvQEHA.3664%40cpmsftngxa10.phx.gbl&rnum=2&prev=/groups%3Fq%3D%2522Win32Exception%2522%2B%2522The%2Bdevice%2Bis%2Bnot%2Bready%2522%26hl%3Dde%26lr%3D%26newwindow%3D1%26selm%3D7%2524tO0xvQEHA.3664%2540cpmsftngxa10.phx.gbl%26rnum%3D2


1.2.12.0
========

- ClientTransaction.Rollback: Bei einem Rollback wurde in einer 1:n Beziehung die DomainObjectCollection durch ein neues Objekt ersetzt. 
  Jetzt wird die gleiche Objektinstanz auf den originalen Inhalt gesetzt.
- ClientTransaction.Commit: Bei einem Commit wurde in einer 1:n Beziehung die DomainObjectCollection mit dem urspünglichen Status der Beziehung 
  durch ein neues Objekt ersetzt. Jetzt wird die gleiche Objektinstanz auf den neuen Inhalt gesetzt.


1.2.11.0
========

- ClientTransaction.Rollback: Wurde nach einem Rollback zu einer 1:n Beziehung ein neues Objekt hinzugefügt/entfernt, 
  wurde der Link auf der n-Seite nicht aktualisiert => Behoben.

- Basisklasse für alle Konfigurationsklassen (Mapping, StorageProviders, Queries) eingeführt. Neue Eigenschaft ApplicationName eingeführt.

- Neue Klasse PerformanceCounters mit Methoden zum Installieren und Deinstallieren der Performance Counter eingeführt.

<= 1.2.10.0
===========

- Beta-Versionen: Sind noch nicht für den Einsatz in einer Produktionsumgebung gedacht.